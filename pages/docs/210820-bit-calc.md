---
title: 비트 연산자
tags: 알고리즘
---



# 비트 연산자

### 비트 연산자

- `&` : 비트 단위로 AND 연산
- `|` : 비트 단위로 OR 연산
- `<<` : 피연산자의 비트열을 왼쪽으로 이동
- `>>` : 피연산자의 비트열을 오른쪽으로 이동
- `1<<n` : 
  - 왼쪽 1을 2진수로 취급하고 n번 왼쪽으로 shift
  - 원소가 n개일 경우의 모든 부분집합의 수 (`2**n` 과 동일)
- `i & (1<<j)` : i의 j번째 비트가 1인지 아닌지 반환





### 비트 연산자를 이용한 부분집합 생성

```python
arr = [1,2,3]
n = len(arr)

for i in range(1<<n):
    for j in range(n):
        if i & (1<<j):
            print(arr[j], end = ', ')
        # print()
    print()
```



### 원리

- 2진법 : `0`과 `1`을 이용해 숫자를 나타내는 방식
- 1은 원소가 포함된 경우, 0은 원소가 포함되지 않은 경우로 간주
  - `[1,2,3]`에서 1, 2를 포함하는 부분집합 --> `[0,1,1]` 
  - 2진법은 셋째, 둘째, 첫째자리 순으로 이뤄짐

```python
# 2진법으로 변환된 부분집합
1		# 001
2		# 010
3		# 100
12		# 011
23		# 110
13		# 101
123		# 111
```

- 모든 부분집합을 2진법으로 나타낸 후, 각 원소값을 알기 위해서는 기존에 주어진 숫자 리스트의 인덱스를 알아야 함
- 각 부분집합의 요소들과 AND(교집합)가 성립하는 인덱스 번호를 알아낸다

```python
index 0		# 001
index 1		# 010
index 2		# 100

# 부분집합이 011인 경우, index 0과 index 1이 겹친다
```

- 교집합이 성립하는 인덱스 번호의 요소를 출력하면 부분집합을 구할 수 있음



### 해석

### 1

```python
for i in range(1<<n):
```

#### `1<<n`

- 왼쪽의 1을 2진수로 취급, n번 왼쪽으로 shift
- `1<<3`의 경우, 2진수 100을 반환
- `2**n` 값과 같으며, 부분집합의 총 개수를 반환



### 2

```python
for j in range(n):
```

- `0 ~ n-1`은 길이가 n인 리스트의 인덱스가 됨
- `n = 3`의 경우, 인덱스값 `0, 1, 2`를 반환



### 3

```python
if i & (1<<j):
    print(arr[j], end = ', ')
```

- `i` : 찾으려는 부분집합 (0과 1로 이루어진 리스트 형태)
- `j` : 리스트의 인덱스 번호
- 찾으려는 부분집합과 현재 인덱스 번호 사이에 교집합이 있는 경우, 원본 리스트에서 해당 인덱스 요소를 출력

```python
# i = 3의 경우
## 3 = 011이기 때문에 0,1번째 인덱스를 가진 1,2가 부분집합으로 나와야 함
3 & 1<<0	# 011 & 001 = 1
3 & 1<<1	# 011 & 010 = 10
3 & 1<<2	# 011 & 100 = 0
```
