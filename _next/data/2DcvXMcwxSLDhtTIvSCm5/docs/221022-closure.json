{"pageProps":{"markdoc":{"content":{"$$mdtype":"Tag","name":"article","attributes":{},"children":[{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"closure"},"children":["Closure"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures#%EC%8B%A4%EC%9A%A9%EC%A0%81%EC%9D%B8_%ED%81%B4%EB%A1%9C%EC%A0%80"},"children":["MDN 클로저 정의"]}]},{"$$mdtype":"Tag","name":"blockquote","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["\"A closure is the combination of a function and the lexical environment within which that function was declared.\""]}]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["클로저는 함수와 함수가 선언된 어휘적 환경(Lexical environment)의 조합을 말합니다."]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"javascript"},"children":["function outer() {\n    var name = 'Mozilla';\n    function inner() {\n        console.log(name);\n    }\n    inner();\n}\nouter(); // Mozilla\n"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":[{"$$mdtype":"Tag","name":"code","attributes":{},"children":["outer()"]}," 함수 안에 내부함수 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["inner()"]},"가 선언되고 호출됐습니다. ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["inner()"]},"는 자신이 속한 lexical scope(자신, ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["outer()"]},", 전역 scope)를 참조하기 때문에 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["Mozilla"]},"가 출력됩니다."]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["이처럼, 클로저란 ",{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["자신이 선언됐을 때의 환경인 스코프를 기억하며, 자신이 선언된 스코프 밖에서 호출되더라도 해당 스코프에 접근할 수 있는 함수"]},"를 말합니다."]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"lexical-scoping"},"children":["Lexical Scoping"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["스코프는 함수를 호출할 때가 아닌, 어디에 선언했는지에 따라 결정됩니다. 이를 어휘적 범위(Lexical Scoping)이라 합니다. 따라서 내부함수가 외부함수 밖에서 실행되더라도 여전히 선언됐을 때의 환경(스코프)를 참조할 수 있습니다."]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"javascript"},"children":["function outer() {\n  var x = 10;\n  function inner() {\n    console.log(x);\n  };\n  return inner;\n}\n\nvar inner = outer();\ninner() // 10\n"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["위 예시에서 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["outer()"]},"는 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["inner()"]},"를 반환한 뒤 콜스택(실행 컨텍스트 스택)에서 제외됩니다. 그러나 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["outer()"]}," 밖에서 실행된 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["inner()"]},"는 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["outer()"]},"에서 선언된 변수 x를 참조할 수 있습니다(Lexical Scoping)."]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"javascript"},"children":["function outer() {\n  var hello = \"hello, \";\n  function inner(name) {\n    console.log(hello + name);\n  };\n  return inner;\n}\n\nvar func1 = outer();\nfunc1(\"John\") // hello, John\n\nvar func2 = outer();\nfunc2(\"Smith\") // hello, Smith\n"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["위 예시에서 볼 수 있듯이 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["func1"]},"과 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["func2"]},"에 할당한 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["inner()"]},"는 서로 독립적인 스코프를 갖고 있습니다. 이처럼 ",{"$$mdtype":"Tag","name":"strong","attributes":{},"children":[{"$$mdtype":"Tag","name":"code","attributes":{},"children":["outer()"]}," 실행 후 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["inner()"]},"가 새 변수에 할당되면 스코프와 로컬 변수 또한 새로 생성됩니다."]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"참고"},"children":["참고"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures"},"children":["MDN 클로저"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://poiemaweb.com/js-closure"},"children":["5.19 Closure 클로저"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://qiita.com/soichirowada/items/c1ba0f4173cddf13ef68"},"children":["JavaScriptのClosure・・・元の場所のスコープって何？"]}]}]}]},"frontmatter":{"title":"Closure","date":"2022-10-22","desc":"javascript 클로저에 대해","tags":"javascript 기술면접"},"file":{"path":"/docs/221022-closure.md"}}},"__N_SSG":true}