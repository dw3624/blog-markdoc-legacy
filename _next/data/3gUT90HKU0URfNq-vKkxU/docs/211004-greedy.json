{"pageProps":{"markdoc":{"content":{"$$mdtype":"Tag","name":"article","attributes":{},"children":[{"$$mdtype":"Tag","name":"Heading","attributes":{"level":1,"id":"완전검색&그리디"},"children":["완전검색&그리디"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"반복과-재귀"},"children":["반복과 재귀"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"반복구조"},"children":["반복구조"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["반복 : 수행하는 작업이 완료될 때까지 계속 반복"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["구조"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["초기화 : 반복 명령문을 실행하기 전에 (한번만) 조건 검사에 사용할 변수의 초깃값 설정"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["조건검사"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["반복할 명령문 실행"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["업데이트 : 무한루프가 되지 않게 조건이 거짓이 되게 한다"]}]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["사례"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["def SelectionSort(A):\n    n = len(A)\n    for i in range(n-1):\n        minI = i\n        for j in range(i+1, n):\n            if A[j] < A[minI]:\n                minI = j\n        A[minI], A[i] = A[i], A[minI]\n"]}]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"재귀적-알고리즘"},"children":["재귀적 알고리즘"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["재귀 : 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용",{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Basis case/rule : 집합에 포함된 원소로 induction를 생성하기 위한 시드(seed) 역할"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Inductive case/rule : 새로운 집합의 원소를 생성하기 위해 결합되는 방법"]}]}]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"재귀-함수"},"children":["재귀 함수"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["일반적으로 재귀적 정의를 이용해 재귀 함수를 구현"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["기본 부분과 유도 부분으로 구성"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["반복구조에 비해 간결하고 이해하기 쉬움"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["프로그램 메모리 구조에서 스택을 사용",{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["메모리 및 속도에서 성능저하 발생"]}]}]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"완전검색기법"},"children":["완전검색기법"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["문제에 포함된 자료의 크기가 작다면 유용"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["수행속도는 느리나 해답을 찾아내지 못할 확률이 작음"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"조합적-문제"},"children":["조합적 문제"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"순열"},"children":["순열"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["서로 다른 것들 중 몇 개를 뽑아 한줄로 나열하는 것"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["$_nP_r$ : 서로 다른 n개 중 r개 선택"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"순열-생성법"},"children":["순열 생성법"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["{1, 2, 3}을 포함하는 모든 순열을 생성하는 함수"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":4,"id":"단순-생성법"},"children":["단순 생성법"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["for i1 in 1 → 3\n\tfor i2 in 1 → 3\n        if i2 ≠ i1\n        \tfor i3 in 1 → 3\n            \tif i3 ≠ i1 and i3 ≠ i2\n                \tprint(i1, i2, i3)\n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":4,"id":"최소변경을-이용한-생성법"},"children":["최소변경을 이용한 생성법"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["이전의 상태에서 두 요소를 교환해 순열 생성"]}]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["# p[] : 데이터가 저장된 배열\n# n : 원소의 개수, i : 선택된 원소의 수\nperm(n, k):\n    if k == n\n    \tprint array # 원하는 작업 수행\n    else\n    \tfor i : k → n-1\n            \tp[k] ↔ p[i]\n                perm(n, k+1)\n                p[k] ↔ p[i]\n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"부분집합"},"children":["부분집합"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["집합에 포함된 원소들을 선택"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["다수의 알고리즘들이 원소들의 그룹에서 초적의 부분 집합을 찾는 것"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["N개의 원소를 포함한 집합"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"부분집합-생성법"},"children":["부분집합 생성법"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":4,"id":"단순-생성법"},"children":["단순 생성법"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["for i1 in 0 → 1\n\tbit[0] ← i1\n    for i2 in 0 → 1\n    \tbit[1] ← i2\n        for i2 in 0 → 1\n\t    \tbit[2] ← i3\n            for i2 in 0 → 1\n\t\t    \tbit[3] ← i4\n                print_array()\n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":4,"id":"바이너리-카운팅-이용한-생성법"},"children":["바이너리 카운팅 이용한 생성법"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["arr = [3, 6, 7, 1, 5, 4]\nn = len(arr)\n\nfor i in range(0, (1<<n)):\n    for j in range(0, n):\n        if i & (1<<j):\n            print('%d'%arr[j], end='')\n        print()\n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"조합"},"children":["조합"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["$_nC_r$ : 서로다른 n개의 원소 중 r개를 순서없이 선택"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["$_nC_r = ",{"$$mdtype":"Tag","name":"em","attributes":{},"children":["{n-1}C"]},"{r-1} + ",{"$$mdtype":"Tag","name":"em","attributes":{},"children":["{n-1}C"]},"{r}$​​"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":4,"id":"재귀호출-이용한-생성법"},"children":["재귀호출 이용한 생성법"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["an[] # n개의 원소를 가지고 있는 배열\ntr[] # r 크기의 배열, 조합이 임시 저장될 배열\n\ncomb(n, r)\n\tif (r == 0) print_arr()\n    else if (n < r) return\n\telse\n    \ttr[r-1] = an[n-1]\n        comb(n-1, r-1)\n        comb(n-1, r)\n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":4,"id":"단순-생성법"},"children":["단순 생성법"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["# i < j < k를 가정\n# a = [0,1,2,3,4,5,6,7,8,9]\nfor i : 0 -> 7\n    for j : i+1 -> 8\n        for k : j+1 -> 9\n            f(a[i],a[j],a[k])\n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":4,"id":"바이너리-카운팅-이용한-생성법"},"children":["바이너리 카운팅 이용한 생성법"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["def nCr(n, r, s, k):\n    # n개에서 r개를 고르는 조합\n    # s 선택할 수 있는 구간의 사작, k 고른 개수\n    if k == r:\n        print(*comb)\n    else:\n        for i in range(s, n-r+k+1):\n            comb[k] = i\n            nCr(n, r, i+1, k+1)\n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"탐욕-알고리즘"},"children":["탐욕 알고리즘"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["최적해를 구하는 데 사용되는 근시안적인 방법"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["여러 경우 중 하나를 선택할 때마다 그 순간에 최적이라 생각되는 것을 선택"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["최종적인 해답이 최적이라는 보장은 없음"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["한번 선택된 것은 번복하지 않음"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["최적화문제 : 가능한 해들 중 가장 좋은 해를 찾는 문제"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"동작과정"},"children":["동작과정"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["해 선택 : 현재 부분 문제의 최적해를 구한 뒤, 부분해 집합에 추가"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["실행 가능성 검사 : 새로운 부분해 집합의 실행가능 여부를 확인 (문제의 제약조건를 위반하지 않는지)"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인, 해가 완성되지 않았다면 해 선택부터 다시 시작"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"필수요소"},"children":["필수요소"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["탐욕적 선택 속성",{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["탐욕적 선택이 최적해로 갈 수 있음을 보여라"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["탐욕적 선택은 항상 안전"]}]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["최적 부분 구조",{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["최적화 문제를 정형화하라"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다"]}]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["[원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해]임을 증명하라"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"동적-계획법과-탐욕-알고리즘의-비교"},"children":["동적 계획법과 탐욕 알고리즘의 비교"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"동적-계획법"},"children":["동적 계획법"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["매 단계의 선택은 해결한 하위 문제의 해를 기반으로 함"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["하위 문제가 우선 해결됨"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Bottom-up 방식"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["비교적 느리고 복잡"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"탐욕기법"},"children":["탐욕기법"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["지역 최적 선택 : 매 단계에서 가장 좋아 보이는 것을 선택"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["하위 문제를 풀기에 앞서, 선택이 먼저 이뤄짐"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Top-down 방식"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["비교적 빠르고 간결"]}]}]},"frontmatter":{"title":"완전검색&그리디","tags":"알고리즘"},"file":{"path":"/docs/211004-greedy.md"}}},"__N_SSG":true}