{"pageProps":{"markdoc":{"content":{"$$mdtype":"Tag","name":"article","attributes":{},"children":[{"$$mdtype":"Tag","name":"Heading","attributes":{"level":1,"id":"stack2"},"children":["Stack2"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"계산기"},"children":["계산기"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["문자열 수식 계산의 일반적 방법"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["중위 표기법의 수식을 후위 표기법으로 변경 (스택 이용)"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["후위 표기법의 수식을 스택으로 이용해 계산"]}]}]}]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"중위/후위-표기법"},"children":["중위/후위 표기법"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["중위 표기법: 연산자를 피연산자의 가운데에 표기 (A+B)"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["연산자 만나면, 스택 top과 비교, 높으면 push"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"code","attributes":{},"children":[")"]},"의 경우 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["("]},"까지 pop 후 ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["("]},", ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":[")"]}," 버림"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["예) ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["2+3*4/5"]},"  -->  ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["2345/*+"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["예) ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["(6+5*(2-8)/2)"]},"  -->  ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["6528-*2/+"]}]}]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["icp(in-coming priority)\nisp(in-stack priority)\n\nif (icp > isp): push()\nelse: pop()\n"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["후위 표기법: 연산자를 피연산자 뒤에 표기 (AB+)"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["피연산자 만나면 스택에 push"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["연산자 만나면 필요한 만큼의 피연산자를 스택에서 pop, 연산결과를 다시 스택에 push"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["수식 종료 후, 마지막으로 스택 pop, 출력"]}]}]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"백트래킹---backtracking"},"children":["백트래킹 - Backtracking"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["해를 찾는 도중 막히면(해가 아니면) 되돌아가 다시 해를 찾는 기법"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["어떤 노드의 유망성을 점검한 후, 유망(promising)하지 않다고 결정되면, 부모 노드로 돌아가 다음 자식 노드로 이동"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["일반적으로 DFS보다 경우의 수 줄어들지만, 최악의 경우 여전히 지수함수 시간 요해, 처리 불가능"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Prunning: 유망하지 않은 노드가 포함된 경로는 고려하지 않음"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["최적화(optimization), 결정(decision) 문제 해결 가능",{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["결정 문제: 문제의 조건을 만족하는 해의 존재 여부를 yes/no로 답하는 문제"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["예) 미로찾기, n-Queen, Map coloring, 부분 집합의 합(subset sum) 등"]}]}]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"깊이우선탐색(dfs)과의-차이"},"children":["깊이우선탐색(DFS)과의 차이"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["DFS : 모든 경로 추적"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["백트래킹: 불필요한 경로 조기 차단"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"과정"},"children":["과정"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["상태 공간 트리의 DFS 실시"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["각 노드가 유망한지 점검"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["만약 해당 노드가 유망하지 않은 경우, 해당 노드의 부모 노드로 돌아가 검색 계속"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"알고리즘"},"children":["알고리즘"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["def checknode(v):\n    if promising(v):\n        if there is a solution at v:\n            write the solution\n        else:\n            for u in each child of v:\n                checknode(u)            \n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":2,"id":"분할정복"},"children":["분할정복"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["분할: 해결할 문제를 여러 개의 작은 부분으로 분할"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["정복: 나눈 작은 문제를 각각 해결"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["통합: (필요하다면) 해결된 해답 수집"]}]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"거듭-제곱---exponentiation"},"children":["거듭 제곱 - Exponentiation"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["def Power(Base, Exponent):\n    if Base == 0: return 1\n    result = 1   # Base^0은 1이므로\n    for i in range(Exponent):\n        result *= Base\n    return result\n"]},{"$$mdtype":"Tag","name":"Heading","attributes":{"level":3,"id":"퀵-정렬"},"children":["퀵 정렬"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["주어진 배열을 두개로 분할하고, 각각 정렬"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["최악의 경우 O(n^2)지만, 평균적으로는 가장 빠름"]}]},{"$$mdtype":"Tag","name":"Fence","attributes":{"data-language":"python"},"children":["def quickSort(a, begin, end):\n    if begin < end:\n        p = partition(a, begin, end)\n        quickSort(a, begin, p-1)\n        quickSort(a, p+1, end)\n        \ndef partition(a, begin, end):\n    pivot = (begin + end) // 2\n    L = begin\n    R = end\n    while L < R:\n        while(a[L] <  a[pivot] and L < R) : L += 1\n        while(a[R] >= a[pivot] and L < R) : R -= 1\n        if L < R:\n            if L == pivot: pivot = R\n                a[L], a[R] = a[R], a[L]\n    a[pivot], a[R] = a[R], a[pivot]\n    return R\n"]}]},"frontmatter":{"title":"스택(2/2)","tags":"알고리즘"},"file":{"path":"/docs/210824-Stack2.md"}}},"__N_SSG":true}